/* eslint-disable @typescript-eslint/no-explicit-any */
export const documentResponse: any = {
  id: "12345",
  query: "What is hybrid search in Weaviate?",
  messages: [
    {
        "type": "User",
        "id": "300a8352-ea42-484b-907e-99104646d48a",
        "query_id": "29f2e422-0754-40f1-a638-e10da1b0bd86",
        "conversation_id": "ace891f1-6af1-4b89-926c-ae0db1b914ee",
        "user_id": "051ae4aa-1841-5419-81e0-bbe2784f6632",
        "payload": {
            "type": "text",
            "metadata": {},
            "code": {
                "language": "",
                "title": "",
                "text": ""
            },
            "objects": [
                "What is hybrid search in Weaviate?"
            ]
        }
    },
    {
        "type": "text",
        "user_id": "051ae4aa-1841-5419-81e0-bbe2784f6632",
        "conversation_id": "ace891f1-6af1-4b89-926c-ae0db1b914ee",
        "query_id": "29f2e422-0754-40f1-a638-e10da1b0bd86",
        "payload": {
            "type": "response",
            "metadata": {},
            "objects": [
                {
                    "text": "I'll search the documentation and blogs for information about hybrid search in Weaviate."
                }
            ]
        }
    },
    {
        "type": "text",
        "user_id": "051ae4aa-1841-5419-81e0-bbe2784f6632",
        "conversation_id": "ace891f1-6af1-4b89-926c-ae0db1b914ee",
        "query_id": "29f2e422-0754-40f1-a638-e10da1b0bd86",
        "payload": {
            "type": "response",
            "metadata": {},
            "objects": [
                {
                    "text": "I'm using a hybrid search to find the most relevant information from both the blogs and documentation."
                }
            ]
        }
    },
    {
        "type": "result",
        "user_id": "051ae4aa-1841-5419-81e0-bbe2784f6632",
        "conversation_id": "ace891f1-6af1-4b89-926c-ae0db1b914ee",
        "query_id": "29f2e422-0754-40f1-a638-e10da1b0bd86",
        "id": "res-6978008e-42db-4c76-a875-386934df17db",
        "payload": {
            "type": "document",
            "objects": [
                {
                    "content": "\n![Vector Search Explained](./img/hero.png)\n\nVector search has fundamentally shifted how we approach information retrieval in modern development. It operates on numerical representations of data called vector embeddings, which capture the semantic meaning in a vector space. Vector search can identify related objects without requiring exact text matches, making it increasingly important for modern information retrieval systems, particularly in AI-native applications where traditional search systems fall short.\n\n##  What is vector search? \n\nVector search is a technique for finding and retrieving similar items in large datasets by comparing their vector representations, which are numerical encodings of their features. Unlike traditional search that relies on exact matches, vector search looks for similarity based on meaning or context. It's used in applications like image retrieval, recommendation systems, and search engines.\n\n## How does vector search work?\n\nVector search works by converting data and queries into [vector embeddings](https://weaviate.io/blog/vector-embeddings-explained). Vector embeddings are generated by language models that learn to capture the meaning and context of data within numerical representations.\n\n![Vector Search](./img/vector-search.png)\n\nAt the time of entry/import (or any significant changes to data objects), every data object, and the query, are converted into numerical vector representations using [embedding models](https://weaviate.io/blog/how-to-choose-an-embedding-model). Every data object in a dataset gets a vector, and this is compared to the query vector at search time.\n\nIn a nutshell, vector embeddings are an array of numbers, which can be used as coordinates in a high-dimensional space. Although it is hard to imagine coordinates in more than 3-dimensional space (x, y, z), we can still use the vectors to compute the distance between vectors, which can be used to indicate similarity between objects. There are many different [distance metrics](https://weaviate.io/blog/distance-metrics-in-vector-search), like [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity) and [Euclidean distance (L2 distance)](https://en.wikipedia.org/wiki/Euclidean_distance). \n\nWhenever we run a query (like: \"What is the tallest building in Berlin?\"), a vector search system will convert it to a \"query\" vector. The task of a vector database is to identify and retrieve a list of vectors that are closest to the vector of your query, using a distance metric and a search algorithm.\n\nThis is a bit like a game of boules ‚Äì where the small marker (jack) is the location of our query vector, and the balls (boules) are our data vectors ‚Äì and we need to find the boules that are nearest to the marker.\n\nAn example of a search algorithm is a [k-nearest neighbors (kNN) algorithm](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm), which returns the k nearest vectors, by calculating a similarity score for every data vector in the database to the query vector. In our boules example, with 6 boules, the kNN algorithm would measure the distance between the jack and each of the 6 boules on the ground. This would result in 6 separate calculations.\n\n\n\n*[kNN search in a game of Boules.]*\n\n## How to implement Vector Search (from scratch) in Python\n\nWe can implement a simple vector search solution from scratch with just a few lines of code in Python.\n\nLet‚Äôs start by installing the OpenAI python package to generate vector embeddings for our text, and numpy to do our similarity calculations.\n\n```\npip install openai\npip install numpy\n```\n\nWe can then import all our dependencies, set our \\`OPENAI\\_API\\_KEY\\`, and define our list of sentences. \n\n```py\nfrom openai import OpenAI\nfrom dotenv import load_dotenv\nimport os\nimport numpy as np\n\nload_dotenv()\n\nclient = OpenAI(\n    api_key=os.getenv(\"OPENAI_API_KEY\"),\n)\n\nsentences = [\n    \"Best pizza places nearby.\",\n    \"Popular breakfast spots in New York.\",\n    \"Top-rated seafood restaurants in Miami.\",\n    \"Cheap hotels near the beach.\",\n    \"Recipes for quick pasta dishes.\",\n]\n```\n\nWe can use OpenAI to generate vector embeddings for every sentence, and store these in a new dictionary. \n\n```py\ndef get_embedding(text, model=\"text-embedding-3-small\"):\n    embedding = client.embeddings.create(input=[text], model=model).data[0].embedding\n    return embedding\n\nsentence_vectors = {}\nfor sentence in sentences:\n    embedding = get_embedding(sentence)\n    sentence_vectors[sentence] = embedding\n\n```\n\nTo calculate the similarity score between the query and each sentence, we can use [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity) scoring method. \n\n```py\ndef calculate_cosine_similarity(query_vector, vector):\n    return np.dot(query_vector, vector) / (np.linalg.norm(query_vector) * np.linalg.norm(vector))\n```\n\nFinally, this function will take our query, convert it to a vector, and calculate the similarity score between every query vector and document vector. Then, it will order the results based on relevance, and return the top two scored sentences. \n\n```py\ndef get_top_n_similar(query_sentence, n=2):\n    query_embedding = get_embedding(query_sentence)\n\n    similarities = {sentence: calculate_cosine_similarity(query_embedding, sentence_vectors[sentence]) for sentence in sentences}\n\n    sorted_similarities = dict(sorted(similarities.items(), key=lambda x: x[1], reverse=True))\n    top_matches = list(sorted_similarities.items())[:n]\n\n    for sentence, score in top_matches:\n        print(f\"Similarity: {score:.4f} - {sentence}\")\n```\n\nYou can see that even though the query and the first returned sentence don‚Äôt have all the words in common, it still scores as a high match because the *meaning* is very similar. \n\n```py\nquery_sentence = \"Find the best pizza restaurant close to me.\"\nget_top_n_similar(query_sentence, n=2)\n```\n\n```\nSimilarity: 0.7056 - Best pizza places nearby.\nSimilarity: 0.3585 - Top-rated seafood restaurants in Miami.\n```\n\nAlthough this method is able to give us similar items based on text vectors, it‚Äôs pretty inefficient. Manually computing cosine similarity over every vector in a large dataset can become computationally expensive fast. Also, without an indexing mechanism, all the vectors are stored in their raw form, requiring high memory consumption and slowing down search speeds. And finally, just storing the vectors and text objects in a dictionary means we lack structured database features. \n\nTo fix all these problems, we can use a vector database to store and search through our vectors. \n\n## Vector search in vector databases\n\nVector search, also called semantic search, using a vector database is able to handle large amounts of [unstructured data](https://weaviate.io/learn/knowledgecards/unstructured-data-objects) (think paragraphs instead of spreadsheets) quickly and efficiently, and provides relevant results in search and recommendation systems based on semantic similarity rather than exact matches. This can allow you to do advanced search through millions of documents, for example, [a Wikipedia dataset with over 28 million paragraphs](https://huggingface.co/datasets/weaviate/wiki-sample).\n\nIf we query for articles related to: \"urban planning in Europe\", the vector database (like [Weaviate](https://weaviate.io/developers/weaviate)) responds with a series of articles about the topic, such as \"The cities designed to be capitals\".\n\nFinding the correct answer in a gigantic repository of unstructured data is not the most impressive part of [vector databases](https://weaviate.io/blog/what-is-a-vector-database) (I mean, it is very impressive), but it is the üöÄ speed at which it all happens. To find the most relevant answer to our semantic search query, it only takes milliseconds in a dataset containing 28 million paragraphs. This is super important when dealing with massive amounts of data, like in recommendation engines or large document datasets. \n\nThe inevitable question that follows up this explanation is always: Why is this so incredibly fast?\n\n### Approximate nearest neighbors (ANN)\n\nInstead of comparing vectors one by one, most vector databases use [Approximate Nearest Neighbor (ANN) algorithms](https://weaviate.io/learn/knowledgecards/ann-approximate-nearest-neighbor), which trade off a bit of accuracy (hence the A in the name) for a huge gain in speed.  \n\nANN algorithms may not return the true k nearest vectors, but they are very efficient. ANN algorithms maintain good performance (sublinear time, e.g. (poly)logarithmic complexity) on very large-scale datasets.\n\n\n\n*[O(n) and O(log n) complexity]*\n\nNote that most vector databases allow you to configure how your ANN algorithm should behave. This lets you find the right balance between the recall tradeoff (the fraction of results that are the true top-k nearest neighbors), latency, throughput (queries per second) and import time.\n\n### Examples of ANN algorithms\n\nExamples of ANN methods are:\n\n* trees ‚Äì e.g. [ANNOY](https://github.com/spotify/annoy) (Figure 3),  \n* proximity graphs \\- e.g. [HNSW](https://arxiv.org/abs/1603.09320) (Figure 4),  \n* clustering \\- e.g. [FAISS](https://github.com/facebookresearch/faiss),  \n* hashing \\- e.g. [LSH](https://en.wikipedia.org/wiki/Locality-sensitive_hashing)\n\n![ANNOY](./img/ann-annoy.png)\n*[Tree-based ANN search]*\n\nWhich algorithm works best depends on your project. Performance can be measured in terms of latency, throughput (queries per second), build time, and accuracy (recall). These four components often have a tradeoff, so it depends on the use case which method works best.  \nSo, while ANN is not some magic method that will always find the true k nearest neighbors in a dataset, it can find a pretty good approximation of the true k neighbors. And it can do this in a fraction of the time!\n\n### HNSW in Weaviate\n\n[Weaviate](https://weaviate.io/developers/weaviate) is a great example of a vector database that uses ANN algorithms to offer ultra-fast queries. The ANN algorithm that Weaviate uses is a custom implementation of [Hierarchical Navigable Small World graphs (HNSW)](https://weaviate.io/developers/weaviate/concepts/vector-index#hnsw).\n\n\n\n*[HNSW - Proximity graph-based ANN search]* \n\nHNSW works by organizing vectors into a hierarchical, multi-layered graph structure, which allows for fast navigation through the dataset during search. The structure of HNSW balances longer distances for faster search in upper layers and shorter distances for accurate search in lower layers.\n\nIn Weaviate's implementation, HNSW is enhanced to support full [CRUD operations](https://weaviate.io/blog/crud-support-in-weaviate) and allows for real-time querying, updates, and deletions, with features like incremental disk writes for crash recovery and [asynchronous cleanup processes](https://github.com/nmslib/hnswlib/issues/4#issuecomment-678315156) for maintaining index freshness.\n\nCheck out [Weaviate ANN benchmarks](https://weaviate.io/developers/weaviate/benchmarks/ann) to see how HNSW performed on realistic large-scale datasets. You can use it to compare the tradeoffs between recall, QPS, latency, and import time.\n\nYou will find it interesting to see that Weaviate can maintain very high recall rates (\\>95%), whilst keeping high throughput and low latency (both in milliseconds). That is exactly what you need for fast, but reliable vector search\\!\n\nIf you‚Äôre interested in benchmarking for your own dataset, [check out this webinar](https://events.weaviate.io/benchmarking-webinar).\n\n### ANN vs. KNN\n\nkNN, or [k-nearest neighbors (kNN) algorithm](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm), differs from ANN because it calculates a similarity score for *every data vector* in the database compared to the query vector, much like our vector search from scratch example above\n\nComparing a query vector with 10, 100, or 1000 data vectors in just two dimensions is an easy job. But of course, in the real world, we are more likely to deal with millions (like in the Wikipedia dataset) or even billions of data items. In addition, the number of dimensions that most embedding models use in semantic search goes up to hundreds or thousands of dimensions\\!\n\nThe *brute force* of a kNN search is computationally very expensive \\- and depending on the size of your database, a single query could take anything from several seconds to even hours (yikes üòÖ). If you compare a vector with 300 dimensions with 10M vectors, the search system would need to do 300 x 10M = 3B computations\\! The number of required calculations increases linearly with the number of data points (O(n)).\n\nIn summary, kNN search doesn't scale well, and it is hard to imagine using it with a large dataset in production.\n\n## Types of vector search\n\nVector search is not just limited to text, or even text in a single language. Anything can be converted into a vector with the right embedding model, whether it‚Äôs images, audio, video, or multi-lingual documents. This means we can develop multi-modal or multi-lingual semantic search systems that can handle a variety of data formats, languages, or search types. \n\n### Image Vector Search\n\n[Image vector search](https://weaviate.io/developers/weaviate/search/image) converts images into vector representations to enable similarity searches between images. The vector embeddings encode features like colors, shapes, and textures so that you can search for images based on visual similarity rather than metadata alone. This type of search is frequently used in fields like e-commerce for finding visually similar products, or in content moderation.\n\n### Audio Vector Search\n\nAudio vector search transforms audio files into vectors to power similarity search based on sound characteristics, such as tone, rhythm, or melody. This is used in applications like music discovery platforms, sound effect libraries, and voice recognition systems.\n\n### Video Vector Search\n\nVideo vector search converts videos into vector embeddings through methods like sampling frames or analyzing scene features for search based on visual and sometimes audio similarity. This method is popular in applications like content libraries, surveillance, and media databases.\n\n### Multimodal Vector Search\n\n![multimodal vector search](./img/any2any_L.png)\n\n[Multimodal vector search](https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_searches/multimodal) combines different data types‚Äîlike text, images, and audio‚Äîin the same vector space for cross-type comparisons. For example, you could find images or audio most similar to a text query, like retrieving images of a lion or a lion‚Äôs roar based on a description alone. This can be used in applications to search across various media formats, like e-commerce, digital asset management, and social media platforms.\n\n### Multilingual Vector Search\n\nMultilingual vector search can compare text across languages by embedding it into the same vector space. For instance, a query in English could retrieve documents, captions, or content in other languages, such as French or Chinese, describing similar concepts. These cross-lingual searches can power applications like global e-commerce, multilingual customer support, and international content discovery.\n\n### Hybrid Search\n\n[Hybrid search](https://weaviate.io/blog/hybrid-search-explained) combines multiple search types, usually vector search and keyword search, in a single system. By combining traditional keyword search with semantic search, we get the best of both worlds: semantic context \\+ specific keywords. Semantic search works great for understanding the general meaning of the documents and query, but it doesn‚Äôt prioritize exact matches such as names, industry-specific jargon, or rare words, which can be helpful in many types of applications. But without semantic search (only keyword), the results can miss relevant semantic information and context about the desired topic. Combining these two methods can improve both the accuracy and relevance of search results.\n\n## Benefits of vector search\n\n[Traditional keyword-based search systems](https://weaviate.io/learn/knowledgecards/keyword-search) can only match *exact terms or phrases*, or key words, in text. In contrast, vector search returns similar items based on their underlying context or meaning, and works with a variety of data types, including text, images, audio or video. For example, a search for \"healthy snacks\" might return semantically related terms like \"nutritious food\" or \"low-calorie treats\", or in the case of a [multimodal system](https://weaviate.io/learn/knowledgecards/multimodal-embeddings-models), pictures of granola bars or fruit. \n\nThis is why vector search is often also called semantic search. It enables a more ‚Äúhuman-like‚Äù search experience, allowing users to find related objects without needing to have the exact right words in their query. \n\n## Vector search use cases\n\nVector search can power a variety of different applications and use cases, from advanced search systems, to recommendation systems, to chatbots.\n\n### Search Systems\n\nVector search can be applied to a wide range of different search systems, from billion-scale e-commerce applications to multi-modal and multi-lingual search apps to internal document search in large enterprises. For example, in e-commerce, semantic search can recommend products based on customer intent, even if they don't have the exact keywords in their search query. With the right embedding model selection, you could create [multilingual](https://weaviate.io/blog/weaviate-non-english-languages), like [WeaLingo](https://weaviate.io/blog/wealingo-demo), or [multimodal](https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_searches/multimodal) search apps out of the box. Vector search can also speed up result time for use cases like enterprise search, because the ANN algorithms allow for such fast retrieval speeds over large numbers of unstructured documents. \n\n### Recommendation Systems\n\nVector search can be used in [recommendation systems](https://weaviate.io/workbench/recommender) to recommend similar products, movies, or content based on user preferences by finding items with similar vector representations, even without shared metadata or tags. This is widely used in social media apps, news sites, or e-commerce stores. \n\n### Retrieval Augmented Generation (RAG)\n\n[Retrieval Augmented Generation](https://weaviate.io/blog/introduction-to-rag), or RAG, is a popular use case of vector search used in applications like chatbots or question-answering systems. RAG is just vector search with an extra added step \\- the similar results returned by the vector database are given to a large language model (LLM) to generate a contextually relevant response to the user‚Äôs query. RAG helps minimize model hallucinations, increase accuracy of responses, and allows generative models to access specialized knowledge to answer complex, data-driven queries. \n\nSemantic search is great for RAG applications because of its speed and ability to search for documents based on meaning, rather than exact matches. \n\n![RAG](./img/rag.png)\n\n## Vector search solutions\n\nThere are a few different ways to enable vector search in applications:  \n\n[**Vector indexing libraries**](https://weaviate.io/blog/vector-library-vs-vector-database#vector-libraries) such as [FAISS](https://github.com/facebookresearch/faiss), [Annoy](https://github.com/spotify/annoy), and [ScaNN](https://github.com/google-research/google-research/tree/master/scann), are optimized for in-memory similarity searches and only store vectors, not the data objects they originate from. Their indexes are generally immutable, meaning they can‚Äôt be updated dynamically without rebuilding. Additionally, vector libraries often require all data to be imported before querying, which can limit their flexibility in dynamic or constantly updating environments. These libraries are good for applications that involve static data and do not need full CRUD operations or persistence capabilities.\n\n**Vector-capable databases** extend traditional databases with vector search capabilities, allowing businesses to incorporate semantic search while leveraging existing database features. These solutions generally struggle with reliability and speed at scale. \n\n[**Vector databases**](https://weaviate.io/blog/what-is-a-vector-database) (such as Weaviate) offer a comprehensive solution to semantic search use cases, supporting vector indexing and also managing data persistence, scaling, and integration with the AI ecosystem. They have flexible solutions for a variety of use cases, from AI applications at scale to users who are just getting started.\n\nA **vector search engine** is often used interchangeably with a vector database, but they are technically different: a vector search engine focuses only on the retrieval layer, while a vector database includes additional features like storage, data management, and clustering.\n\n## Vector search FAQs\n\n### Semantic search vs Vector search\n\nIn terms of formal definitions, vector search is just the process of arranging vector embeddings, or vectors, into a vector index to perform similarity searches, while semantic search builds on the basic definition of vector search to return more relevant results based on the meaning of text rather than exact terms. In practice, though, vector search and semantic search are often used interchangeably. \n\n### Vector search vs Keyword search\n\nVector search finds similar items based on the semantic meaning of the data, while keyword search relies on exact word matches or phrase occurrences. Vector search can handle unstructured, multimodal data (like text, images or audio) and find related concepts, while keyword search is more suited for structured text data where exact phrasing is important.\n\n### How is vector search conducted at scale?\n\nVector databases use Approximate Nearest Neighbor (ANN) algorithms to speed up search time for large datasets. With ANN algorithms, vector search can return similar items to the query within a few milliseconds, even out of billions of objects. \n\n## Summary\n\nA quick recap:\n* Vector search, also called semantic search, can identify related objects without requiring exact text matches, allowing users to search based on semantic meaning rather than exact keywords.   \n* It uses machine learning models to generate vector embeddings for all data objects and the query, and doing math calculations to determine similarity.  \n* Vector embeddings capture the meaning and context of data.  \n* Vector databases offer super fast responses to queries thanks to ANN algorithms.  \n* ANN algorithms trade a small amount of accuracy for huge gains in speed.  \n* Different types of vector search include hybrid search or multimodal search for images, audio, or video.  \n* Use cases of vector search include Retrieval Augmented Generation (RAG), recommendation systems, or search systems. \n\n\n",
                    "title": "Blog Vector-search-explained",
                    "category": [
                        "Blog"
                    ],
                    "uuid": "3946f91d-61ca-4410-b1d1-23ec2032912b",
                    "collection_name": "Weaviate_blogs",
                    "chunk_spans": [
                        {
                            "start": 15125,
                            "end": 15955,
                            "uuid": "34b638ea-e600-5d28-873a-30f9fbeac1db"
                        }
                    ]
                },
                {
                    "content": "\nHybrid search is a technique that **combines multiple search algorithms** to improve the accuracy and relevance of search results. It uses the best features of both keyword-based search algorithms with vector search techniques. By leveraging the strengths of different algorithms, it provides a more effective search experience for users.\n\nThe [hybrid search](/hybrid-search) feature was introduced in Weaviate `1.17`. It uses sparse and dense vectors to represent the semantic meaning and context of search queries and documents.\nIn this blog post, you will learn the definition of hybrid search, the role of sparse and dense vectors, when to use hybrid search, and more about the implementation of [hybrid search](/developers/weaviate/api/graphql/search-operators#hybrid) in Weaviate and how to use it.\n\n## Sparse and Dense Vectors\nSparse and dense vectors are calculated with distinct algorithms. Sparse vectors have mostly zero values with only a few non-zero values, while dense vectors mostly contain non-zero values. Sparse embeddings are generated from algorithms like [BM25](https://en.wikipedia.org/wiki/Okapi_BM25) and [SPLADE](https://arxiv.org/abs/2107.05720). Dense embeddings  are generated from machine learning models like [GloVe](https://text2vec.org/glove.html) and [Transformers](https://huggingface.co/docs/transformers/index).\n\nNote, the current implementation of hybrid search in Weaviate uses BM25/BM25F and vector search.\n\nIf you‚Äôre interested to learn about how dense vector indexes are built and optimized in Weaviate, check out this [article](/blog/vector-search-explained).\n\n### BM25\nBM25 builds on the keyword scoring method [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) (Term-Frequency Inverse-Document Frequency) by taking the [Binary Independence Model](https://en.wikipedia.org/wiki/Binary_Independence_Model) from the IDF calculation and adding a normalization penalty that weighs a document‚Äôs length relative to the average length of all the documents in the database.\n\nThe formula below presents the scoring calculation of BM25:\n\n$$\nscore(D, Q) = \\sum_{i=1}^{n} IDF(q_i) \\frac{f(q_i, D) \\cdot (k_1 + 1)}{f(q_i, D) + k_1 \\cdot (1 - b + b \\cdot \\frac{|D|}{avgd_1})}\n$$\n\n\n\nSource: Wikipedia page on Okapi BM25\n\n\nThe score of the document, query pair is determined by weighing the uniqueness of each keyword in the query relative to the collection of texts. BM25 contains additional static parameters, k1 and b that may help calibrate performance to particular datasets.\n\n### BM25F\nBM25F was also implemented in Weaviate `1.17`. BM25F is a variant of BM25 that allows multiple text fields per object to be given different weights in the ranking calculation. These weights are important for when fields in a document are more important than others. For example, a title may be given more weight than the abstract, since the title is sometimes more informative and concise. This type of weighting makes BM25F more flexible and customizable than BM25.\n\n### Dense Vector\n\nDense vectors represent information stored in a database; this includes text, images, and other types of data. These embeddings are generated from machine learning models that convert data to vectors. The vectors are densely packed with information and are mostly made up of non-zero values. The meaning of each value in the vector depends on the machine learning model that you used.\n\n[Vector databases](/blog/what-is-a-vector-database), like [Weaviate](/developers/weaviate), store these embeddings and calculate the distance between the two vectors. [Distance metrics](/blog/distance-metrics-in-vector-search) show how similar or dissimilar two [vector embeddings](/blog/vector-embeddings-explained) are. The search query is converted to a vector, similar to the data vectors, and the distance value determines how close the vectors are.\n\n![hybrid search](img/hybrid-search.png)\n\n## What is Hybrid Search?\nHybrid search merges dense and sparse vectors together to deliver the best of both search methods. Generally speaking, dense vectors excel at understanding the context of the query, whereas sparse vectors excel at keyword matches. Consider the query, ‚ÄúHow to catch an Alaskan Pollock‚Äù. The dense vector representation is able to disambiguate ‚Äúcatch‚Äù as meaning fishing rather than baseball or sickness. The sparse vector search will match the phrase ‚ÄúAlaskan Pollock‚Äù only. This example query shows where hybrid search combines the best of both sparse and dense vectors.\n\n## How does Hybrid Search Work?\n\nHybrid search works by combining the results of sparse vector search (e.g., BM25) and dense vector search into a single, ranked list. To achieve this, Weaviate first performs both a vector search and a keyword search in parallel. The results from these searches are then handed to a fusion algorithm, such as Reciprocal Rank Fusion (RRF), which combines and ranks the objects into a single list.\n\nRRF ensures that relevant results from both search types are fairly represented, penalizing documents ranked lower in either list. [Benham and Culpepper](https://arxiv.org/abs/1811.06147) (2018) explored a variety of rank fusion techniques to improve search results. This paper analyzed seven strategies for combining the ranked results of two lists into a single ranking. Let‚Äôs dig into how the RRF score is calculated.\n\nThe RRF score is calculated by taking the sum of the reciprocal rankings that is given from each list. By putting the rank of the document in the denominator, it penalizes the documents that are ranked lower in the list.\n\n$$\n\\sum_{d \\in D} \\frac{1}{k + r(d)}\n$$\n\n\nSource: Benham and Culpepper, 2018\n\n\nLet's look at an example of this. We have three documents labeled `A`, `B`, and `C` and have run a BM25 and Dense search. In this example, we have set the constant *k* to 0.\n\n| BM25 Ranking | Dense Ranking | Results |\n| ----- | ----- | ----- |\n| A | B | A: 1/1 + 1/3 = 1.3 |\n| B | C | B: 1/2 + 1/1 = 1.5 |\n| C | A | C: 1/3 + 1/2 = 0.83 |\n\nThe above table shows the ranked order of the BM25 and Dense search. To fuse the two lists together, we need to take the sum of the reciprocal ranks. Based on the results, the top document is `Document B` with a ranking of 1.5, then `Document A` at 1.3, and `Document C` at 0.83.\n\nWeaviate supports two fusion algorithms, `rankedFusion` and `relativeScoreFusion`. `rankedFusion` is the default fusion algorithm, however you can change it in the `fusionType` parameter.\n\nFor a deep dive into how Weaviate's hybrid search combines sparse and dense vectors, you can read more on these [fusion algorithms in our blog post](/blog/hybrid-search-fusion-algorithms).\n\n## When to Use Hybrid Search?\nHybrid search queries are ideal for a search system that wants to leverage the power of semantic search capabilities but still rely on exact keyword matches. For example, the example search query \"How to catch an Alaskan Pollock\" from before would lead to better results with a hybrid search query than with a common keyword search or even a semantic search query.\n\n## Advantages of Hybrid Search\nHybrid search engines bring several advantages that make it a powerful approach for modern search systems, especially when both semantic understanding and exact keyword matching are essential. This dual approach excels in handling diverse user queries, whether they are domain-specific queries requiring exact matches or semantic queries that rely on context and meaning. For instance, in scenarios where users might include ambiguous phrases, domain-specific terms, or misspellings in their queries, hybrid search ensures relevant results by understanding the query's intent while still honoring exact matches for critical keywords.\n\nIn addition to its flexibility, hybrid search significantly improves the user experience by reducing the need for perfectly phrased queries. Dense vector embeddings capture the semantic meaning behind a search query, making it easier to handle multi-concept or even multilingual queries. Its ability to seamlessly integrate semantic relationships with precise keyword matches ensures more accurate and contextually relevant outcomes.\n\nThis makes hybrid search engines an ideal choice for applications in e-commerce, customer support, and other search-driven domains.\n\n## A Simple Hybrid Search Pipeline in Weaviate\nTo use [Weaviate hybrid search](/developers/weaviate/search/hybrid) you only need to confirm that you‚Äôre using Weaviate `v1.17` or a later version. There are five parameters needed to run the hybrid search query (some are optional):\n\n* `hybrid`: shows that you want to use a hybrid search query\n* `query`: search query\n* `alpha` (optional, default is `0.75`): weighting for each search algorithm\n  * `alpha` = 0 -> pure keyword search\n  * `alpha` = 0.5 -> equal weighing of keyword and vector search\n  * `alpha` = 1 -> pure vector search\n* `vector` (optional): optional to supply your own vector\n* `score` (optional): additional information on how much the sparse and dense methods contributed to the result\n* `fusionType` (optional, default is`rankedFusion`): choose the fusion algorithm\n\nWith just a few lines of code, you can start using hybrid search. The query is, ‚ÄúFisherman that catches salmon‚Äù (similar to the example above). When we set the alpha to 0.5 it is equally weighing the dense and sparse vector results.\n\n```python\nresponse = article.query.hybrid(\nquery=\"fisherman that catches salmon\",\nalpha =0.5,\nreturn_metadata=MetadataQuery(score=True, explain_score=True)\nfor o in response.objects:\n    print(o.properties)\n    print(o.metadata.score, o.metadata.explain_score)\n```\n\nYou can find end-to-end notebooks on using hybrid search in [Weaviate Recipes](https://github.com/weaviate/recipes/tree/main/weaviate-features/hybrid-search)!\n\n## Summary\n\nThis article explained the concept of hybrid search. In the context of the Weaviate vector database, hybrid search is a combination of keyword search and semantic search. By combining these two types of searches, hybrid search queries can lead to more relevant results in use cases where you want to leverage the power of semantic search but also rely on exact matches of certain keywords, such as product or brand names.\n\nCheck out the [documentation](/developers/weaviate/api/graphql/search-operators#hybrid) for more information on hybrid search\\!\n\nimport WhatNext from '/_includes/what-next.mdx'\n\n\n",
                    "title": "Blog Hybrid-search-explained",
                    "category": [
                        "Blog"
                    ],
                    "uuid": "84868634-def3-4642-8f76-29eef97967dc",
                    "collection_name": "Weaviate_blogs",
                    "chunk_spans": [
                        {
                            "start": 6454,
                            "end": 7442,
                            "uuid": "db88eaf3-9bc9-5e88-9ed1-4e62afb44960"
                        },
                        {
                            "start": 9177,
                            "end": 9953,
                            "uuid": "1982ad01-350d-5aea-a775-eaf278a89545"
                        },
                        {
                            "start": 9836,
                            "end": 10385,
                            "uuid": "110a1dc4-dfe7-5076-ba50-ae9ba66d4cb5"
                        },
                        {
                            "start": 0,
                            "end": 532,
                            "uuid": "d49124ff-e954-57d1-823a-bbf25480c40f"
                        }
                    ]
                }
            ],
            "metadata": {
                "collection_name": "Weaviate_blogs",
                "display_type": "document",
                "summarise_items": false,
                "query_text": "What is hybrid search in Weaviate?",
                "query_type": "hybrid",
                "chunked": true,
                "query_output": {
                    "target_collections": [
                        "ELYSIA_CHUNKED_weaviate_blogs__",
                        "Weaviate_documentation"
                    ],
                    "search_type": "hybrid",
                    "search_query": "What is hybrid search in Weaviate?",
                    "sort_by": null,
                    "filter_buckets": null,
                    "limit": 5
                },
                "code": {
                    "language": "python",
                    "title": "Query",
                    "text": "collection.query.hybrid(\n    query='What is hybrid search in Weaviate?',\n    limit=5\n)"
                }
            },
            "code": {
                "language": "python",
                "title": "Query",
                "text": "collection.query.hybrid(\n    query='What is hybrid search in Weaviate?',\n    limit=5\n)"
            }
        }
    },
    {
        "type": "result",
        "user_id": "051ae4aa-1841-5419-81e0-bbe2784f6632",
        "conversation_id": "ace891f1-6af1-4b89-926c-ae0db1b914ee",
        "query_id": "29f2e422-0754-40f1-a638-e10da1b0bd86",
        "id": "res-cacfa27f-aac4-4edf-9173-f6172b20da17",
        "payload": {
            "type": "document",
            "objects": [
                {
                    "title": "Which-search Review",
                    "content": "\n##  Overview\n\nWeaviate offers three primary search types - namely **vector**, **keyword**, and **hybrid** searches. Let's briefly recap what they are, and how they work.\n\n###  Code examples\n\nThese code examples are runnable, with the [`v3` Weaviate Typescript client](/developers/weaviate/client-libraries/typescript/typescript-v3.mdx). Connect to the pre-configured demo instance of Weaviate with the following code, and try the examples below.\n\n\n\n \n    \n  \n\n\n\n##  Vector search\n\nA vector search finds objects with the most similar vectors to the query vector.\n\nBecause each vector is a numerical representation of the underlying object, a vector similarity can be thought of as a similarity in meaning. Therefore a vector search is also called \"semantic search\".\n\nIn Weaviate, you can search for objects with similar vectors in any of the following ways:\n\nWith a source medium (e.g. text or image):\n\n\n\n \n    \n  \n\n\n\nWith a vector:\n\n\n\n \n    \n  \n\n\n\nWith an existing Weaviate object:\n\n\n\n \n    \n  \n\n\n\n##  Keyword search\n\nA keyword search finds objects whose keywords (i.e. tokens) are the most relevant to the keywords (i.e. tokens) of the query. The relevance is determined by the [BM25F algorithm](https://en.wikipedia.org/wiki/Okapi_BM25).\n\nIntuitively, the BM25F algorithm determines \"relevance\" by considering how often a keyword appears in each field of the object, relative to how commonly the keyword appears in the entire dataset.\n\n\n\n \n    \n  \n\n\n\n##  Hybrid search\n\nA hybrid search combines the results of a vector search and a keyword search. This is done by performing both searches, and them combining the two search results with a \"fusion\" algorithm.\n\n\n\n \n    \n  \n\n\n",
                    "category": [
                        "Documentation"
                    ],
                    "uuid": "192c778f-2683-4ded-ab17-907c8075aa56",
                    "collection_name": "Weaviate_documentation",
                    "chunk_spans": []
                },
                {
                    "title": "Which_search Review",
                    "content": "\n##  Overview\n\nWeaviate offers three primary search types - namely **vector**, **keyword**, and **hybrid** searches. Let's briefly recap what they are, and how they work.\n\n###  Code examples\n\nThese code examples are runnable, with the [`v4` Weaviate Python client](/developers/weaviate/client-libraries/python/index.md). Connect to the pre-configured demo instance of Weaviate with the following code, and try the examples below.\n\n\n\n \n    \n  \n\n\n\n##  Vector search\n\nA vector search finds objects with the most similar vectors to the query vector.\n\nBecause each vector is a numerical representation of the underlying object, a vector similarity can be thought of as a similarity in meaning. Therefore a vector search is also called \"semantic search\".\n\nIn Weaviate, you can search for objects with similar vectors in any of the following ways:\n\nWith a source medium (e.g. text or image):\n\n\n\n \n    \n  \n\n\n\nWith a vector:\n\n\n\n \n    \n  \n\n\n\nWith an existing Weaviate object:\n\n\n\n \n    \n  \n\n\n\n##  Keyword search\n\nA keyword search finds objects whose keywords (i.e. tokens) are the most relevant to the keywords (i.e. tokens) of the query. The relevance is determined by the [BM25F algorithm](https://en.wikipedia.org/wiki/Okapi_BM25).\n\nIntuitively, the BM25F algorithm determines \"relevance\" by considering how often a keyword appears in each field of the object, relative to how commonly the keyword appears in the entire dataset.\n\n\n\n \n    \n  \n\n\n\n##  Hybrid search\n\nA hybrid search combines the results of a vector search and a keyword search. This is done by performing both searches, and them combining the two search results with a \"fusion\" algorithm.\n\n\n\n \n    \n  \n\n\n",
                    "category": [
                        "Documentation"
                    ],
                    "uuid": "cf66a008-c9fd-4c89-9b26-fc4dcd3116a5",
                    "collection_name": "Weaviate_documentation",
                    "chunk_spans": []
                },
                {
                    "title": "Search Hybrid",
                    "content": "\n`Hybrid` search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\n\nThe [fusion method](#change-the-fusion-method) and the [relative weights](#balance-keyword-and-vector-search) are configurable.\n\n## Basic hybrid search\n\nCombine the results of a vector search and a keyword search. The search uses a single query string.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Named vectors\n\n\nA hybrid search on a collection that has [named vectors](../config-refs/schema/multi-vector.md) must specify a `target` vector. Weaviate uses the query vector to search the target vector space.\n\n\n  \n    \n  \n  \n    \n  \n  \n    \n  \n  \n    \n  \n  \n    \n  \n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Explain the search results\n\nTo see the object rankings, set the `explain score` field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Balance keyword and vector search\n\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the `alpha` value in your query.\n\n- An `alpha` of `1` is a pure vector search.\n- An `alpha` of `0` is a pure keyword search.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Change the fusion method\n\n`Relative Score Fusion` is the default fusion method starting in `v1.24`.\n\n- To use the keyword and vector search relative scores instead of the search rankings, use `Relative Score Fusion`.\n- To use [`autocut`](../api/graphql/additional-operators.md#autocut) with the `hybrid` operator, use `Relative Score Fusion`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n\n  \n    Additional information\n  \n\nFor a discussion of fusion methods, see [this blog post](/blog/hybrid-search-fusion-algorithms) and [this reference page](../api/graphql/search-operators.md#variables-2)\n\n\n\n## Specify keyword search properties\n\n\nThe keyword search portion of hybrid search can be directed to only search a subset of object properties. This does not affect the vector search portion.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Set weights on property values\n\nSpecify the relative value of an object's `properties` in the keyword search. Higher values increase the property's contribution to the search score.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Specify a search vector\n\nThe vector component of hybrid search can use a query string or a query vector. To specify a query vector instead of a query string, provide a query vector (for the vector search) and a query string (for the keyword search) in your query.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Vector search parameters\n\n\nYou can specify [vector similarity search](/developers/weaviate/search/similarity) parameters similar to [near text](/developers/weaviate/search/similarity.md#search-with-text) or [near vector](/developers/weaviate/search/similarity.md#search-with-a-vector) searches, such as `group by` and `move to` / `move away`. An equivalent `distance` [threshold for vector search](./similarity.md#set-a-similarity-threshold) can be specified with the `max vector distance` parameter.\n\n\n  \n    \n  \n\n  \n    \n  \n  \n    \n  \n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Hybrid search thresholds\n\n\nThe only available search threshold is `max vector distance`, which will set the maximum allowable distance for the vector search component.\n\n\n  \n    \n  \n\n  \n\n\n    \n  \n  \n\n\n## Group results\n\n\nDefine criteria to group search results.\n\n\n  \n    \n  \n\n  \n    \n  \n\n\n\n  Example response\n\nThe response is like this:\n\n```\n'Jeopardy!'\n'Double Jeopardy!'\n```\n\n\n\n## `limit` & `offset`\n\nUse `limit` to set a fixed maximum number of objects to return.\n\nOptionally, use `offset` to paginate the results.\n\n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n\n## Limit result groups\n\nTo limit results to groups with similar distances from the query, use the [`autocut`](../api/graphql/additional-operators.md#autocut) filter. Specify the `Relative Score Fusion` ranking method when you use autocut with hybrid search.\n\n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n  \n    \n  \n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n## Filter results\n\nTo narrow your search results, use a [`filter`](../api/graphql/filters.md).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n\n\n\n\n\n  Example response\n\nThe output is like this:\n\n\n\n\n\n### Tokenization\n\nimport TokenizationNote from '/_includes/tokenization.mdx'\n\n\n\n## Related pages\n\n- [Connect to Weaviate](/developers/weaviate/connections/index.mdx)\n- [API References: Search operators # Hybrid](../api/graphql/search-operators.md#hybrid)\n- [Weaviate Academy: Tokenization](../../academy/py/tokenization/index.md)\n- About [hybrid fusion algorithms](/blog/hybrid-search-fusion-algorithms).\n- For tutorials, see [Queries](/developers/weaviate/tutorials/query.md)\n- For search using the GraphQL API, see [GraphQL API](../api/graphql/get.md).\n\n## Questions and feedback\n\n\n",
                    "category": [
                        "Documentation"
                    ],
                    "uuid": "de1cd7b8-9b7f-45c7-89c2-7030e27831cc",
                    "collection_name": "Weaviate_documentation",
                    "chunk_spans": []
                },
                {
                    "title": "Weaviate Search",
                    "content": "\nUse these **search** how-to guides to find the data you want.\n\nThe [query basics](./basics.md) page covers basic search syntax and how to specify the properties you want to retrieve.\n\nThese guides cover additional search topics:\n\n- [Vector similarity search](./similarity.md): Covers `nearXXX` searches that search for objects with the most similar vector embeddings to the query.\n- [Image search](./image.md): Use images as input for a similarity search.\n- [Keyword search](./bm25.md): A keyword search that uses the BM25F algorithm to rank results.\n- [Hybrid search](./hybrid.md): Combines BM25 and similarity search to rank results.\n- [Retrieval augmented generation](./generative.md): Use search results as a prompt for an LLM.\n- [Reranking](./rerank.md): Rerank retrieved search results using a `reranker` module.\n- [Aggregation](./aggregate.md): Aggregate data from a results set.\n- [Filters](./filters.md): Apply conditional filters to the search.\n\n## Questions and feedback\n\n\n",
                    "category": [
                        "Documentation"
                    ],
                    "uuid": "ec6fafe7-d4d2-4bb3-89bd-c649c2c29b82",
                    "collection_name": "Weaviate_documentation",
                    "chunk_spans": []
                },
                {
                    "title": "Standalone Which-search",
                    "content": "\n##  Unit overview\n\n\n -->\n\n\n\n\n\nWeaviate offers three distinct search methods - namely **vector**, **keyword**, and **hybrid** searches.\n\nEach method has its unique strengths and applicabilities, making the selection critical to the success of your search-related tasks.\n\nThis section compares these search types to equip you with the knowledge to intuit when and why to employ each of these search methodologies.\n\nWe will explore how the choice of search type impacts not only the quality of the search results but also the overall performance of the search operation.\n\nThen, we will also discuss strategies to improve the quality of search results, as well as the performance of the search operation.\n\n\n###  Prerequisites\n\n- A Node.js environment with `weaviate-client` installed.\n- Familiarity with Weaviate's search capabilities.\n- Intermediate coding proficiency (e.g. JavaScript).\n\n##  Learning objectives\n\n\n\n\n\n## Questions and feedback\n\n\n",
                    "category": [
                        "Documentation"
                    ],
                    "uuid": "512adbb3-3e0a-45ef-85fb-b286dfeb6831",
                    "collection_name": "Weaviate_documentation",
                    "chunk_spans": []
                }
            ],
            "metadata": {
                "collection_name": "Weaviate_documentation",
                "display_type": "document",
                "summarise_items": false,
                "query_text": "What is hybrid search in Weaviate?",
                "query_type": "hybrid",
                "chunked": false,
                "query_output": {
                    "target_collections": [
                        "ELYSIA_CHUNKED_weaviate_blogs__",
                        "Weaviate_documentation"
                    ],
                    "search_type": "hybrid",
                    "search_query": "What is hybrid search in Weaviate?",
                    "sort_by": null,
                    "filter_buckets": null,
                    "limit": 5
                },
                "code": {
                    "language": "python",
                    "title": "Query",
                    "text": "collection.query.hybrid(\n    query='What is hybrid search in Weaviate?',\n    limit=5\n)"
                }
            },
            "code": {
                "language": "python",
                "title": "Query",
                "text": "collection.query.hybrid(\n    query='What is hybrid search in Weaviate?',\n    limit=5\n)"
            }
        }
    },
    {
        "type": "text",
        "user_id": "051ae4aa-1841-5419-81e0-bbe2784f6632",
        "conversation_id": "ace891f1-6af1-4b89-926c-ae0db1b914ee",
        "query_id": "29f2e422-0754-40f1-a638-e10da1b0bd86",
        "payload": {
            "type": "response",
            "metadata": {},
            "objects": [
                {
                    "text": "I'll summarise the information I found about hybrid search in Weaviate."
                }
            ]
        }
    },
    {
        "type": "text",
        "user_id": "051ae4aa-1841-5419-81e0-bbe2784f6632",
        "conversation_id": "ace891f1-6af1-4b89-926c-ae0db1b914ee",
        "query_id": "29f2e422-0754-40f1-a638-e10da1b0bd86",
        "payload": {
            "type": "summary",
            "metadata": {},
            "objects": [
                {
                    "text": "Hybrid search in Weaviate combines keyword search and semantic (vector) search to leverage the strengths of both. It uses both sparse and dense vectors to represent the meaning of search queries and documents. This approach is useful when you want to utilize semantic search while also relying on exact keyword matches, such as product or brand names. By combining these search methods, hybrid search provides a more effective search experience, especially when both semantic understanding and exact keyword matching are essential. You can configure the weights of the keyword and vector components using the `alpha` parameter, where 1 is a pure vector search and 0 is a pure keyword search.",
                    "title": "Hybrid Search in Weaviate Explained"
                }
            ]
        }
    }
]}